bool IsCompleteBinaryTree2()  
{  
	queue<Node *>q;  
	q.push(_root);  
	Node *cur=q.front();  
	//按照层序遍历的办法入队列直到遇到第一个NULL停止  
	while (cur)  
	{  
		q.push(cur->_left);  
		q.push(cur->_right);  
		q.pop();  
		cur=q.front();  
	}  
	//如果队列中全为NULL则是完全二叉树，否则不是  
	while(!q.empty())  
	{  
		if(q.front())  
			return false;  
		q.pop();  
	}  
	return true;  
}  
struct biTree {

		char data;

			struct biTree *lchild;

				struct biTree *rchild;

				
};

struct Stack {

		biTree *arr;

			int len;

				int top;

				
};

#include <stdio.h>
#include <stdlib.h>
struct biTree *pre = NULL;
struct biTree *h = (struct biTree *)malloc(sizeof(struct biTree));//创建一个头结点
biTree *leafLink(biTree *b) {//将二叉树b中的所有叶子结点连起来

	if (b) {

		leafLink(b->lchild);//中序遍历左子树

		if (!b->lchild && !b->rchild) {//叶节点

			if (pre==NULL) {//处理第一个节点

				h = b;

				pre = b;

			}

			else {

				pre->rchild = b;

				pre = b;


			}

		}

		leafLink(b->rchild);//中序遍历右子树

		pre->rchild = NULL;//设置链表尾


	}

	return h;

}

int main() {

	struct biTree *b = (struct biTree *)malloc(sizeof(struct biTree ));

	biTree *create(biTree *);

	b = create(b);//创建一颗二叉树

	leafLink(b);

	while (h) {

		printf("%c ", h->data);

		h = h->rchild;


	}

	return 0;


}
